"""
Run tests on inStrain compare
"""

import glob
import os
import shutil
from collections import defaultdict
from subprocess import call
import importlib
import logging
import pytest

import numpy as np
import pandas as pd
import pysam

import inStrain
import inStrain.SNVprofile
import inStrain.argumentParser
import inStrain.polymorpher
import inStrain.controller
import inStrain.profile.fasta
import inStrain.profile.profile_utilities
import inStrain.profile.snv_utilities
import inStrain.readComparer
import inStrain.compare_utils
import tests.test_utils as test_utils

from test_utils import BTO

def test_polymorpher_integrated_0(BTO):
    """
    Run a test of polymorpher outputs generated by default during compare
    """
    # Run program
    base = BTO.test_dir + 'RC_test'

    cmd = f"inStrain compare -p 1 --debug -i {BTO.IS1} {BTO.IS2} -o {base} -sc {BTO.scafflistF} --store_mismatch_locations --bams {BTO.bam1} {BTO.bam2}"
    print(cmd)
    #call(cmd, shell=True)
    inStrain.controller.Controller().main(inStrain.argumentParser.parse_args(cmd.split(' ')[1:]))

    rawfiles = glob.glob(base + '/raw_data/*')
    assert len(rawfiles) == 7

    # Make sure it produced output
    outfiles = glob.glob(base + '/output/*')
    assert len(outfiles) == 5

    # Check the output files
    kdb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_data_keys.tsv',
        sep='\t')
    ddb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_data.tsv',
        sep='\t')
    idb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_info.tsv',
        sep='\t')


    S1 = inStrain.SNVprofile.SNVprofile(BTO.IS1)
    S2 = inStrain.SNVprofile.SNVprofile(BTO.IS2)
    sdb1 = S1.get('cumulative_snv_table').rename(
                columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                         'baseCoverage': 'position_coverage'})
    sdb1['sample'] = 'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G1.sorted.bam'
    sdb1 = sdb1.sort_values('mm').drop_duplicates(subset=['scaffold', 'position'], keep='last').sort_index().drop(columns=['mm'])


    sdb2 = S2.get('cumulative_snv_table').rename(
        columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                 'baseCoverage': 'position_coverage'})
    sdb2['sample'] = 'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G2.sorted.bam'
    sdb2 = sdb2.sort_values('mm').drop_duplicates(subset=['scaffold', 'position'], keep='last').sort_index().drop(
        columns=['mm'])

    cdb = pd.concat([sdb1, sdb2])

    # Subset to the scaffolds that are profiled
    cdb = cdb[cdb['scaffold'].isin(kdb['scaffold'])]
    cdb['SNV_key'] = [f"{s}_{p}" for s, p in zip(cdb['scaffold'], cdb['position'])]

    # Un-key the data
    k2sa = kdb.set_index('key')['sample'].to_dict()
    k2s = kdb.set_index('key')['scaffold'].to_dict()

    ddb['scaffold2'] = [k2s[s] for s in ddb['scaffold']]
    ddb['sample2'] = [k2sa[s] for s in ddb['sample']]
    ddb['SNV_key'] = [f"{s}_{p}" for s, p in zip(ddb['scaffold2'], ddb['position'])]

    # Make sure the SNVs are right
    assert set(ddb['SNV_key']) == set(cdb['SNV_key'])

    idb['SNV_key'] = [f"{s}_{p}" for s, p in zip(idb['scaffold'], idb['position'])]
    assert set(idb['SNV_key']) == set(cdb['SNV_key']) == set(ddb['SNV_key'])

    # Check row by row
    for i, row in cdb.iterrows():
        # check ddb
        db = ddb[(ddb['sample2'] == row['sample']) & (ddb['position'] == row['position']) & (
                    row['scaffold'] == ddb['scaffold2'])]
        assert len(db) == 1, db

        for x in ['A', 'C', 'T', 'G']:
            if db[x].iloc[0] != row[x]:
                print(row)
                for r in db.iterrows():
                    print(r)
            assert db[x].iloc[0] == row[x]

        # check idb
        name = row['class'] + '_count'
        iidb = idb[(idb['position'] == row['position']) & (row['scaffold'] == idb['scaffold'])]
        assert iidb[name].iloc[0] > 0

def test_polymorpher_integrated_1(BTO):
    """
    Run a test of polymorpher outputs generated by default during compare
    """
    # Run program
    base = BTO.test_dir + 'RC_test'

    cmd = f"inStrain compare --debug -i {BTO.IS1} {BTO.IS2} -o {base} --bams {BTO.bam1} {BTO.bam2}"
    print(cmd)
    call(cmd, shell=True)
    #inStrain.controller.Controller().main(inStrain.argumentParser.parse_args(cmd.split(' ')[1:]))

    # Make sure it produced output
    outfiles = glob.glob(base + '/output/*')
    assert len(outfiles) == 4, outfiles

    rawfiles = glob.glob(base + '/raw_data/*')
    assert len(rawfiles) == 6

    # Check the output files
    kdb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_data_keys.tsv',
        sep='\t')
    ddb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_data.tsv',
        sep='\t')
    idb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_info.tsv',
        sep='\t')


    S1 = inStrain.SNVprofile.SNVprofile(BTO.IS1)
    S2 = inStrain.SNVprofile.SNVprofile(BTO.IS2)
    sdb1 = S1.get('cumulative_snv_table').rename(
                columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                         'baseCoverage': 'position_coverage'})
    sdb1['sample'] = 'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G1.sorted.bam'
    sdb1 = sdb1.sort_values('mm').drop_duplicates(subset=['scaffold', 'position'], keep='last').sort_index().drop(columns=['mm'])


    sdb2 = S2.get('cumulative_snv_table').rename(
        columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                 'baseCoverage': 'position_coverage'})
    sdb2['sample'] = 'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G2.sorted.bam'
    sdb2 = sdb2.sort_values('mm').drop_duplicates(subset=['scaffold', 'position'], keep='last').sort_index().drop(
        columns=['mm'])

    cdb = pd.concat([sdb1, sdb2])

    # Subset to the scaffolds that are profiled
    cdb = cdb[cdb['scaffold'].isin(kdb['scaffold'])]
    cdb['SNV_key'] = [f"{s}_{p}" for s, p in zip(cdb['scaffold'], cdb['position'])]

    # Un-key the data
    k2sa = kdb.set_index('key')['sample'].to_dict()
    k2s = kdb.set_index('key')['scaffold'].to_dict()

    ddb['scaffold2'] = [k2s[s] for s in ddb['scaffold']]
    ddb['sample2'] = [k2sa[s] for s in ddb['sample']]
    ddb['SNV_key'] = [f"{s}_{p}" for s, p in zip(ddb['scaffold2'], ddb['position'])]

    # Make sure the SNVs are right
    assert set(ddb['SNV_key']) == set(cdb['SNV_key'])

    idb['SNV_key'] = [f"{s}_{p}" for s, p in zip(idb['scaffold'], idb['position'])]
    assert set(idb['SNV_key']) == set(cdb['SNV_key']) == set(ddb['SNV_key'])

    # Check row by row
    for i, row in cdb.iterrows():
        # check ddb
        db = ddb[(ddb['sample2'] == row['sample']) & (ddb['position'] == row['position']) & (
                    row['scaffold'] == ddb['scaffold2'])]
        assert len(db) == 1, db

        for x in ['A', 'C', 'T', 'G']:
            if db[x].iloc[0] != row[x]:
                print(row)
                for r in db.iterrows():
                    print(r)
            assert db[x].iloc[0] == row[x]

        # check idb
        name = row['class'] + '_count'
        iidb = idb[(idb['position'] == row['position']) & (row['scaffold'] == idb['scaffold'])]
        assert iidb[name].iloc[0] > 0

def test_polymorpher_integrated_2(BTO):
    """
    Run a test of polymorpher outputs generated by default during compare WITH --skip_popANI
    """
    # Run program
    base = BTO.test_dir + 'RC_test'

    cmd = f"inStrain compare --debug -i {BTO.IS1} {BTO.IS2} -o {base} --bams {BTO.bam1} {BTO.bam2} --skip_popANI"
    print(cmd)
    call(cmd, shell=True)
    #inStrain.controller.Controller().main(inStrain.argumentParser.parse_args(cmd.split(' ')[1:]))

    # Make sure it produced output
    outfiles = glob.glob(base + '/output/*')
    assert len(outfiles) == 3, outfiles

    rawfiles = glob.glob(base + '/raw_data/*')
    assert len(rawfiles) == 5

    # Check the output files
    kdb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_data_keys.tsv',
        sep='\t')
    ddb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_data.tsv',
        sep='\t')
    idb = pd.read_csv(
        f'{base}/output/RC_test_pooled_SNV_info.tsv',
        sep='\t')


    S1 = inStrain.SNVprofile.SNVprofile(BTO.IS1)
    S2 = inStrain.SNVprofile.SNVprofile(BTO.IS2)
    sdb1 = S1.get('cumulative_snv_table').rename(
                columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                         'baseCoverage': 'position_coverage'})
    sdb1['sample'] = 'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G1.sorted.bam'
    sdb1 = sdb1.sort_values('mm').drop_duplicates(subset=['scaffold', 'position'], keep='last').sort_index().drop(columns=['mm'])


    sdb2 = S2.get('cumulative_snv_table').rename(
        columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                 'baseCoverage': 'position_coverage'})
    sdb2['sample'] = 'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G2.sorted.bam'
    sdb2 = sdb2.sort_values('mm').drop_duplicates(subset=['scaffold', 'position'], keep='last').sort_index().drop(
        columns=['mm'])

    cdb = pd.concat([sdb1, sdb2])

    # Subset to the scaffolds that are profiled
    cdb = cdb[cdb['scaffold'].isin(kdb['scaffold'])]
    cdb['SNV_key'] = [f"{s}_{p}" for s, p in zip(cdb['scaffold'], cdb['position'])]

    # Un-key the data
    k2sa = kdb.set_index('key')['sample'].to_dict()
    k2s = kdb.set_index('key')['scaffold'].to_dict()

    ddb['scaffold2'] = [k2s[s] for s in ddb['scaffold']]
    ddb['sample2'] = [k2sa[s] for s in ddb['sample']]
    ddb['SNV_key'] = [f"{s}_{p}" for s, p in zip(ddb['scaffold2'], ddb['position'])]

    # Make sure the SNVs are right
    assert set(ddb['SNV_key']) == set(cdb['SNV_key'])

    idb['SNV_key'] = [f"{s}_{p}" for s, p in zip(idb['scaffold'], idb['position'])]
    assert set(idb['SNV_key']) == set(cdb['SNV_key']) == set(ddb['SNV_key'])

    # Check row by row
    for i, row in cdb.iterrows():
        # check ddb
        db = ddb[(ddb['sample2'] == row['sample']) & (ddb['position'] == row['position']) & (
                    row['scaffold'] == ddb['scaffold2'])]
        assert len(db) == 1, db

        for x in ['A', 'C', 'T', 'G']:
            if db[x].iloc[0] != row[x]:
                print(row)
                for r in db.iterrows():
                    print(r)
            assert db[x].iloc[0] == row[x]

        # check idb
        name = row['class'] + '_count'
        iidb = idb[(idb['position'] == row['position']) & (row['scaffold'] == idb['scaffold'])]
        assert iidb[name].iloc[0] > 0

def test_polymorpher_integrated_3(BTO):
    """
    Run a test of polymorpher with database mode
    """
    # Set up
    location1 = os.path.join(BTO.test_dir, os.path.basename(BTO.IS1))
    shutil.copytree(BTO.IS1, location1)
    location2 = os.path.join(BTO.test_dir, os.path.basename(BTO.IS2))
    shutil.copytree(BTO.IS2, location2)

    # Run the program in one step
    base = BTO.test_dir + 'RC_test'

    # Make sure it raises an exception if the profiles don't have genome level info
    try:
        cmd = f"inStrain compare --debug -i {location1} {location2} -o {base} --bams {BTO.bam1} {BTO.bam2} --skip_popANI -s {BTO.stb2} --database_mode"
        print(cmd)
        inStrain.controller.Controller().main(inStrain.argumentParser.parse_args(cmd.split(' ')[1:]))
        assert False
    except:
        pass

    call(f"inStrain genome_wide -i {location1} -s {BTO.stb2}", shell=True)
    call(f"inStrain genome_wide -i {location2} -s {BTO.stb2}", shell=True)

    # Run for real
    cmd = f"inStrain compare --debug -i {location1} {location2} -o {base} --bams {BTO.bam1} {BTO.bam2} --skip_popANI -s {BTO.stb2} --database_mode"
    print(cmd)
    call(cmd, shell=True)

    # Make sure it produced output
    outfiles = glob.glob(base + '/output/*')
    assert len(outfiles) == 3, outfiles

    rawfiles = glob.glob(base + '/raw_data/*')
    assert len(rawfiles) == 6, rawfiles

def test_polymorpher_log(BTO):
    """
    Run a test of polymorpher outputs generated by default during compare
    """
    # Run program
    base = BTO.test_dir + 'RC_test'

    cmd = f"inStrain compare --debug -i {BTO.IS1} {BTO.IS2} -o {base} -sc {BTO.scafflistF} --store_mismatch_locations --bams {BTO.bam1} {BTO.bam2}"
    print(cmd)
    call(cmd, shell=True)
    #inStrain.controller.Controller().main(inStrain.argumentParser.parse_args(cmd.split(' ')[1:]))

    rawfiles = glob.glob(base + '/raw_data/*')
    assert len(rawfiles) == 7

    # Make sure it produced output
    outfiles = glob.glob(base + '/output/*')
    assert len(outfiles) == 5

    exp_RC = inStrain.SNVprofile.SNVprofile(base)

    # Make sure log is working
    assert len(glob.glob(base + '/log/*')) == 3, glob.glob(base + '/log/*')
    Ldb = exp_RC.get_parsed_log()
    print(Ldb)

def test_polymorpher_unit_0(BTO):
    """
    Test the ability to extract SNPs from a .bam file
    """
    bam_loc = BTO.bam1
    IS_loc = BTO.IS1

    # Load a list of positions to extract
    ISP = inStrain.SNVprofile.SNVprofile(IS_loc)
    SSdb = ISP.get_nonredundant_snv_table()

    # Load R2M
    R2M = ISP.get('Rdic')
    #print(ISP)

    for scaffold, Sdb in SSdb.groupby('scaffold'):
        Sdb = Sdb[(Sdb['scaffold'] == scaffold) & (Sdb['cryptic'] == False)][['scaffold', 'position', 'A', 'C', 'T', 'G', 'cryptic']]

        # Re_extract these
        position2counts = inStrain.polymorpher.extract_SNVS_from_bam(bam_loc, R2M[scaffold], Sdb['position'].tolist(), scaffold)

        # Compare
        for i, row in Sdb.iterrows():
            position = row['position']
            table_counts = [row['A'], row['C'], row['T'], row['G']]

            if position not in position2counts:
                print(scaffold)
                print(position)
                print(Sdb)

            calcd_counts = position2counts[position]

            if set(table_counts == calcd_counts) != set([True]):
                print(scaffold)
                print(row)
                print(table_counts)
                print(calcd_counts)

                assert False

def test_polymorpher_unit_1(BTO):
    """
    Test "extract_SNV_positions"
    """
    S1 = inStrain.SNVprofile.SNVprofile(BTO.IS1)
    S2 = inStrain.SNVprofile.SNVprofile(BTO.IS2)

    tables = [S1.get('cumulative_snv_table').rename(
                columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                         'baseCoverage': 'position_coverage'}),
             S2.get('cumulative_snv_table').rename(
             columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                     'baseCoverage': 'position_coverage'})]

    names = [os.path.basename(S1.get('bam_loc')), os.path.basename(S2.get('bam_loc'))]

    scaffolds = set(tables[0]['scaffold']).intersection(set(tables[1]['scaffold']))

    name2scaffs = {}
    name2SNPtables = {}

    for name, table in zip(names, tables):
        name2SNPtables[name] = table[table['cryptic'] == False]
        name2scaffs[name] = scaffolds

    name2scaff2locs, scaff2all = inStrain.polymorpher.extract_SNV_positions(name2SNPtables, name2scaffs)

    for scaff in scaffolds:
        scaff_tables = [x[(x['scaffold'] == scaff) & (x['cryptic'] == False)] for x in tables]

        assert set(scaff_tables[0]['position']).union(set(scaff_tables[1]['position'])) \
               - set(scaff_tables[0]['position']).intersection(set(scaff_tables[1]['position'])) \
               == set(name2scaff2locs[names[0]][scaff]).union(set(name2scaff2locs[names[1]][scaff]))

    #
    # for scaff in scaffolds:
    #     scaff_tables = [x[(x['scaffold'] == scaff) & (x['cryptic'] == False)] for x in tables]
    #
    #
    #     name2locs, all_SNVs = inStrain.polymorpher.extract_SNV_positions(scaff_tables, names)
    #
    #     assert set(scaff_tables[0]['position']).union(set(scaff_tables[1]['position'])) \
    #            - set(scaff_tables[0]['position']).intersection(set(scaff_tables[1]['position'])) \
    #            == set(name2locs[names[0]]).union(set(name2locs[names[1]]))

def test_polymorpher_unit_2(BTO):
    """
    Test DDST and PST generation
    """
    S1 = inStrain.SNVprofile.SNVprofile(BTO.IS1)
    S2 = inStrain.SNVprofile.SNVprofile(BTO.IS2)

    tables = [S1.get('cumulative_snv_table').rename(
        columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                 'baseCoverage': 'position_coverage'}),
        S2.get('cumulative_snv_table').rename(
            columns={'conBase': 'con_base', 'refBase': 'ref_base', 'varBase': 'var_base',
                     'baseCoverage': 'position_coverage'})]

    tables = [x.sort_values('mm')\
            .drop_duplicates(subset=['scaffold', 'position'], keep='last')\
            .sort_index().drop(columns=['mm']) for x in tables]

    names = [os.path.basename(S1.get('bam_loc')), os.path.basename(S2.get('bam_loc'))]
    scaffolds = set(tables[0]['scaffold']).intersection(set(tables[1]['scaffold']))

    name2Rdic = {names[0]:S1.get('Rdic'),
                 names[1]: S2.get('Rdic')}
    name2bam_loc = {names[0]:BTO.bam1,
                  names[1]: BTO.bam2}

    for scaff in scaffolds:

        scaff_tables = [x[(x['scaffold'] == scaff) & (x['cryptic'] == False)] for x in tables]

        PM = inStrain.polymorpher.PoolController(scaff_tables, names, name2Rdic, name2bam_loc, scaff)
        PM.main()

        DSTdb = PM.DDST
        assert set(DSTdb.index.get_level_values(0)) == set(names)
        assert set(DSTdb.index.get_level_values(1)) == set(scaff_tables[0]['position']).union(set(scaff_tables[1]['position']))
        assert len(DSTdb) == (len(set(scaff_tables[0]['position']).union(set(scaff_tables[1]['position']))) * len(names))

        PMdb = PM.PST
        assert set(PMdb.index) == set(scaff_tables[0]['position']).union(set(scaff_tables[1]['position']))
        assert len(PMdb) == len(set(scaff_tables[0]['position']).union(set(scaff_tables[1]['position'])))

def test_polymorpher_unit_3(BTO):
    """
    Test .bam file argparse functionality
    """
    base = BTO.test_dir + 'RC_test'

    # Input 1 - bam files in the correct order
    cmd = f"inStrain compare -i {BTO.IS1} {BTO.IS2} -o {base} -sc {BTO.scafflistF} --include_self_comparisons --store_mismatch_locations --bams {BTO.bam1} {BTO.bam2}"
    sys_args = cmd.split(' ')
    args = inStrain.argumentParser.parse_args(sys_args[1:])

    OC = inStrain.compare_controller.CompareController(args)
    OC.parse_arguments()
    print(OC.name2bam)
    assert OC.name2bam == {'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G1.sorted.bam': '/Users/mattolm/Programs/inStrain/test/test_data/N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G1.sorted.bam', 'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G2.sorted.bam': '/Users/mattolm/Programs/inStrain/test/test_data/N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G2.sorted.bam'}

    # Input 2 - bams in incorrect order
    cmd = f"inStrain compare -i {BTO.IS1} {BTO.IS2} -o {base} -sc {BTO.scafflistF} --include_self_comparisons --store_mismatch_locations --bams {BTO.bam2} {BTO.bam1}"
    sys_args = cmd.split(' ')
    args = inStrain.argumentParser.parse_args(sys_args[1:])

    OC = inStrain.compare_controller.CompareController(args)
    OC.parse_arguments()
    print(OC.name2bam)
    assert OC.name2bam != {
        'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G1.sorted.bam': '/Users/mattolm/Programs/inStrain/test/test_data/N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G1.sorted.bam',
        'N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G2.sorted.bam': '/Users/mattolm/Programs/inStrain/test/test_data/N5_271_010G1_scaffold_min1000.fa-vs-N5_271_010G2.sorted.bam'}

    #print(args)